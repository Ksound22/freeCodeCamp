---
id: 67f39dac6c3fac29c3d54918
title: Object Oriented Programming Review
challengeType: 31
dashedName: review-object-oriented-programming
---

# --description--

## What is Object-Oriented Programming?

- Object-oriented programming is a programming style in which developers treat everything in their code like a real-world object. It is popularly called OOP.
- Classes form the blueprint for creating objects.
- Every single object created from a class has attributes that define data and methods that define the behaviours of the objects.
- Object-oriented programming has four key principles that help you organize and manage code effectively. They are:
  - encapsulation
  - inheritance
  - polymorphism
  - abstraction

## What is Object-Oriented Programming?

- Encapsulation is the bundling of the attributes and methods of an object into a single unit.
- Encapsulation lets you hide the internal state of the object behind a simple set of public methods and attributes that act like doors.
- Behind those doors are private attributes and methods that control how the data changes and who can see it.
- For example, if you want to track a wallet balance, you will allow deposit and withdrawal, but you won't want anyone to tamper with the wallet balance itself:

```py
class Wallet:
   def __init__(self, balance):
       self.__balance = balance # Private attribute

   def deposit(self, amount):
       if amount > 0:
           self.__balance += amount # Add to the balance safely

   def withdraw(self, amount):
       if 0 < amount <= self.__balance:
           self.__balance -= amount # Remove from the balance safely

account = Wallet(500)
print(account.__balance) # AttributeError: 'Wallet' object has no attribute '__balance'
```

- Prefixing attributes and methods with a single underscore means they are meant for internal use. This is a convention, and it doesn't enforce accessing attributes from the outside.
- Prefixing attributes and methods with a double underscore effectively prevents them from being accessed from outside of their class.

## What Are Getters and Setters?

- Getters and setters are methods that let you control how the attributes of a class are accessed and modified
- You retrieve values with getters.
- You set values with setters.
- Properties are what connect getters and setters, and allow access to data.
- Properties run extra logic behind the scenes when you get, set, or delete values.
- For this purpose, properties are used instead of methods for better readability and cleaner code. They let you access values with dot notation, like regular attributes, without parentheses.
- To create a getter, you use the `@property` decorator. Here's a getter that gets the radius of a circle:

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self): # A getter to get the radius
        return self._radius
  
    @property
    def area(self):  # A getter to calculate area
        return 3.14 * (self._radius ** 2)

my_circle = Circle(3)

print(my_circle.radius) # 3
print(my_circle.area) # 28.26
```

- To create the setter that will set the radius, you have to define another method with the same name and use `@<property_name>.setter` above it:

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):  # A getter to get the radius
        return self._radius

    @radius.setter
    def radius(self, value):  # A setter to set the radius
        if value <= 0:
            raise ValueError('Radius must be positive')
        self._radius = value

my_circle = Circle(3)
print('Initial radius:', my_circle.radius) # Initial radius: 3

my_circle.radius = 8
print('After modifying the radius:', my_circle.radius) # After modifying the radius: 8
```

- Once you define getters and setters, Python automatically calls them under the hood whenever you use normal attribute syntax this way:

```py
my_circle.radius # This will call the getter
my_circle.radius = 4 # This will call the setter
```

- When setting a value, you should not assign to the property name itself because that will cause a `RecursionError`. Use a separate internal name, often with an underscore, to store the value.
- After setting and getting a value with setter and getter, you can control how it is deleted with a `deleter`.
- A deleter runs custom logic when you use the `del` statement on a property.
- To create a deleter, you use the `@<property_name>.deleter` decorator.

```py
  # Deleter
    @radius.deleter
    def radius(self):
        print("Deleting radius...")
        del self._radius
```

# --assignment--

Review the Object Oriented Programming topics and concepts.
